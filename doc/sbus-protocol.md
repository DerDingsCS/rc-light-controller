# S.Bus

S.Bus is a proprietary protocol developed by Futaba.
(Dead link: https://www.futabarc.com/sbus/index.html)

S.Bus2 is an extension that supports telemetry.

Some receivers on the market output an "inverted SBUS" signal. However, it seems that those receivers are not suitable for RC cars as they only have S.Bus / Inverted S.Bus output and no traditional PWM servo output.

For the light controller it only makes sense to implement standard S.Bus, which is supported by Futaba and FrSky receivers.


## S.Bus, as LANE Boys RC understands it

(Source: https://quadmeup.com/generate-s-bus-with-arduino-in-a-simple-way/)

* The serial port uses 100000 BAUD, 8 bits, even parity, 2 stop bits (!)
* There is also a fast mode that uses 200000 BAUD, 8 bits, even parity, 2 stop bits (The light controller will not support this mode)
* Packets containing servo information are sent at regular intervals of about 10-20ms (FrSky: 6ms Futaba/FrSky fast mode: 3ms)
* When the connection with the Transmitter is broken, the receiver sets a FAILSAFE flag in the packet

* A packet is always 25 bytes long and contains the following information:
    * 1 byte HEADER
    * 22 bytes payload for 16 servo channels (11 bits per channel)
    * 1 byte bit-field payload containing:
        * Bit 0: channel 17
        * Bit 1: channel 18
        * Bit 2: lost frame
        * Bit 3: failsafe
    * 1 byte FOOTER or FOOTER 2

* The HEADER byte is 0x0f
* The FOOTER byte is 0x00
* The FOOTER2 byte is 0x4 or 0x8 (contents of the upper nibble is ignored, it contains a slot number for telemetry use)
* FOOTER is used in the original S.Bus protocol, while S.Bus2 changed to FOOTER2.
* The upper nibble of FOOTER2 contains a slot number used for telemetry (see _Example packets_ below).

* The servo information is 11 bits per channel
    Channel values describe the servo pulse duration from 0..2047


## Impact of S.Bus support on the light controller

The S.Bus system uses an inverted UART signal (idle=low).

The LPC812 and LPC832 do not support inverted UART, hence S.Bus can not be supported without additional hardware.
(It would be possible to support "inverted SBUS" (idle=high), but as stated above this may not be useful due to lack of receiver support).

For the Mk4P and Mk4S PCB we could integrate an inverter (1 MosFET, 1 Resistor) and route the inverted UART signal to an unused pin (e.g. GPIO10). The software could then route the UART RX line to GPIO10 if S.Bus is configured.

For the user this means that only newer revisions of the Mk4P light controller (Rev3) can support S.Bus.


The Baudrate used by S.Bus is 100000. This is a non-standard Baudrate, but it should be possible with the LPC8xx microcontroller. However, in case a Slave is used the Baudrate of the Slave would also have to be 100000 Baud.

The WebUSB programmer and the CH340G chip used in the USB-to-Serial dongle do neither support 100000 Baud nor the inverted UART signal. It will therefore not possible to implement the "Testing" function in the Configurator for S.Bus.


## Example packets

(Source: https://github.com/mikeshub/FUTABA_SBUS/blob/master/FUTABA_SBUS/FUTABA_SBUS.cpp):

```
0x0f 0x01 0x04 0x20 0x00 0xff 0x07 0x40 0x00 0x02 0x10 0x80 0x2c 0x64 0x21 0x0b 0x59 0x08 0x40 0x00 0x02 0x10 0x80 0x00 0x00
```

(Source: https://www.rcgroups.com/forums/showthread.php?2420473-Arduino-S-BUS-Packet-Generator-Code)

```
0x0f 0x5c 0x91 0x26 0x37 0x7f 0xa4 0x6a 0xab 0x00 0x10 0x80 0x00 0x04 0x20 0x00 0x01 0x08 0x70 0x00 0x02 0x10 0x80 0x0c 0x00
```

S-Bus data sent from Futaba R7008SB in "FASSTest 14ch" mode:
```
0x0f 0x04 0x1c 0xa1 0x43 0x09 0x48 0x40 0x04 0x7a 0x10 0x2c 0x00 0x04 0x20 0x58 0xc0 0x13 0x07 0x38 0x00 0x10 0x80 0x00 0x04
0x0f 0x04 0x1c 0xa1 0x43 0x09 0x48 0x40 0x04 0x7a 0x10 0x2c 0x00 0x04 0x20 0x58 0xc0 0x13 0x07 0x38 0x00 0x10 0x80 0x00 0x14
0x0f 0x04 0x1c 0xa1 0x43 0x09 0x48 0x40 0x04 0x7a 0x10 0x2c 0x00 0x04 0x20 0x58 0xc0 0x13 0x07 0x38 0x00 0x10 0x80 0x00 0x24
0x0f 0x04 0x1c 0xa1 0x43 0x09 0x48 0x40 0x04 0x7a 0x10 0x2c 0x00 0x04 0x20 0x58 0xc0 0x13 0x07 0x38 0x00 0x10 0x80 0x00 0x34
```

S-Bus data sent from Futaba R7008SB in FASSTest 12CH mode (packets may be in shorter intervals):
```
0x0f 0x00 0x1c 0x20 0x5b 0x09 0x08 0xc0 0x13 0x7a 0x10 0x2c 0x00 0x04 0x20 0x00 0x01 0x08 0x40 0x00 0x02 0x10 0x80 0x00 0x08
0x0f 0x00 0x1c 0x21 0x59 0x09 0x08 0xc0 0x13 0x7a 0x10 0x2c 0x00 0x04 0x20 0x00 0x01 0x08 0x40 0x00 0x02 0x10 0x80 0x00 0x08
0x0f 0x00 0x1c 0x21 0x5b 0x09 0x08 0xc0 0x13 0x7a 0x10 0x2c 0x00 0x04 0x20 0x00 0x01 0x08 0x40 0x00 0x02 0x10 0x80 0x00 0x08
0x0f 0x00 0x1c 0x21 0x5b 0x09 0x08 0xc0 0x13 0x7a 0x10 0x2c 0x00 0x04 0x20 0x00 0x01 0x08 0x40 0x00 0x02 0x10 0x80 0x00 0x08
0x0f 0x00 0x1c 0x21 0x59 0x09 0x08 0xc0 0x13 0x7a 0x10 0x2c 0x00 0x04 0x20 0x00 0x01 0x08 0x40 0x00 0x02 0x10 0x80 0x00 0x08
```

S-Bus output from FrSky TFR8SB receiver in FASST-MULTI mode:
```
0x0f 0x04 0x1c 0xa1 0x43 0x0b 0x48 0x40 0x04 0x7a 0x10 0x2c 0x00 0x04 0x20 0x58 0xc0 0x13 0x07 0x38 0x00 0x10 0x80 0x00 0x00
0x0f 0x04 0x1c 0xa1 0x43 0x0b 0x48 0x40 0x04 0x7a 0x10 0x2c 0x00 0x04 0x20 0x58 0xc0 0x13 0x07 0x38 0x00 0x10 0x80 0x00 0x00
0x0f 0x04 0x1c 0xa1 0x43 0x0b 0x48 0x40 0x04 0x7a 0x10 0x2c 0x00 0x04 0x20 0x58 0xc0 0x13 0x07 0x38 0x00 0x10 0x80 0x00 0x00
0x0f 0x04 0x1c 0xa1 0x43 0x0b 0x48 0x40 0x04 0x7a 0x10 0x2c 0x00 0x04 0x20 0x58 0xc0 0x13 0x07 0x38 0x00 0x10 0x80 0x00 0x00
```


## Open points:

* There is conflicting info about the meaning of the servo channel value range.

Is 1024 center? https://github.com/mikeshub/FUTABA_SBUS/blob/master/FUTABA_SBUS/FUTABA_SBUS.cpp
Or 992? https://quadmeup.com/generate-s-bus-with-arduino-in-a-simple-way/

BetaFlight uses the following formula to convert S.Bus servo information to microseconds (servo pulse):
servo_us = (5 * sbus / 8) + 880;

Using this formula would make S.Bus value 1024 translate to 1520 us, which is exactly what Futaba traditionally used as center value for servos.

But how does FrSky map the S.Bus values? Most likely they are using 1500 as center, hence the 992 value.


* What are the possible values for FOOTER2?

https://github.com/cleanflight/cleanflight/issues/590#issuecomment-101027349
https://github.com/cleanflight/cleanflight/issues/590#issuecomment-101706023


* Frame detection

Most libraries seem to use HEADER and FOOTER/FOOTER2 to detect frames. Those libraries will not work with the FASSTest 12CH mode, which uses 0x08 last byte.

BetaFlight uses the maximum frame time of 3000 us + 500 us margin. If the time since the last byte is more than 3500us then a start of frame is assumed. This will only work with interrupt-driven UART receive.
(Source: https://github.com/betaflight/betaflight/blob/master/src/main/rx/sbus.c)